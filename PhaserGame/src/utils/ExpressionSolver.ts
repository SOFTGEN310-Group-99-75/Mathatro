import { evaluateExpression } from './ExpressionEvaluator';
import { checkObjective } from './ObjectiveChecker';

export interface SolveCheckResult {
  solvable: boolean;
  expression?: string;
  value?: number;
}

/**
 * Brute-force enumerates possible linear expressions from the provided hand tokens
 * (numbers & operators) to determine if any satisfy the objective.
 * Tokens can be used at most once. Expressions are formed as n op n op n ...
 */
export function isObjectiveSolvable(hand: string[], objective: string, options: { maxNumbers?: number } = {}): SolveCheckResult { // NOSONAR cognitive complexity acceptable for exhaustive search
  const numbers = hand.filter(t => /^\d+$/.test(t));
  const operators = hand.filter(t => /^[+\-*/^]$/.test(t));
  if (numbers.length < 2 || operators.length < 1) return { solvable: false };

  const maxNumbers = Math.min(options.maxNumbers ?? 5, numbers.length);

  // Build a multiset count map for operators
  const opCounts: Record<string, number> = {};
  for (const op of operators) opCounts[op] = (opCounts[op] || 0) + 1;

  const usedNum: boolean[] = new Array(numbers.length).fill(false);
  const exprCache = new Set<string>();

  function collectNumberPermutations(k: number): string[][] {
    const results: string[][] = [];
    const acc: string[] = [];
    const usedAtDepth: Set<string>[] = Array.from({ length: k }, () => new Set());
    function backtrack(depth: number) {
      if (depth === k) { results.push(acc.slice()); return; }
      const seen = usedAtDepth[depth];
      for (let i = 0; i < numbers.length; i++) {
        if (usedNum[i]) continue;
        const val = numbers[i];
        if (seen.has(val)) continue;
        seen.add(val);
        usedNum[i] = true;
        acc.push(val);
        backtrack(depth + 1);
        acc.pop();
        usedNum[i] = false;
      }
    }
    backtrack(0);
    return results;
  }

  function collectOperatorSequences(len: number): string[][] {
    const results: string[][] = [];
    const ops = Object.keys(opCounts);
    const counts: Record<string, number> = { ...opCounts };
    const acc: string[] = [];
    function backtrack() {
      if (acc.length === len) { results.push(acc.slice()); return; }
      for (const op of ops) {
        if (counts[op] > 0) {
          counts[op]--;
            acc.push(op);
            backtrack();
            acc.pop();
            counts[op]++;
        }
      }
    }
    backtrack();
    return results;
  }

  for (let k = 2; k <= maxNumbers; k++) {
    const numPerms = collectNumberPermutations(k);
    for (const numSeq of numPerms) {
      const opLen = k - 1;
      const opSeqs = collectOperatorSequences(opLen);
      for (const opSeq of opSeqs) {
        const tokens: string[] = [];
        for (let i = 0; i < numSeq.length; i++) {
          tokens.push(numSeq[i]);
          if (i < opSeq.length) tokens.push(opSeq[i]);
        }
        const exprKey = tokens.join(' ');
        if (exprCache.has(exprKey)) continue;
        exprCache.add(exprKey);

        // Basic invalid pattern skips
        if (/[^\d)]\s*[*/^]\s*0(\s|$)/.test(exprKey)) {
          // allow 0 in general but skip division by zero or power base issues indirectly
        }
        // Prevent division by zero evaluation attempts
        if (/\/\s*0(\s|$)/.test(exprKey)) continue;

        const value = evaluateExpression(tokens);
        if (!Number.isFinite(value)) continue;
        // Avoid astronomically large numbers generated by power chains
        if (Math.abs(value) > 1e9) continue;
        if (checkObjective(value, objective)) {
          return { solvable: true, expression: exprKey, value };
        }
      }
    }
  }

  return { solvable: false };
}
